/**
 * UNIFIED COMPREHENSIVE ECONOMY COMMAND for ATIVE Casino Bot
 * ALL economy functionality in ONE extremely detailed, analytical command with graphs
 * Shows EVERYTHING: server overview, personal analytics, taxation, gambling stats, wealth distribution
 */

const { SlashCommandBuilder, AttachmentBuilder } = require('discord.js');
const { createCanvas } = require('canvas');
const dbManager = require('../../UTILS/database');
const wealthTaxManager = require('../../UTILS/wealthTax');
const shopManager = require('../../UTILS/shopManager');
const economicManager = require('../../UTILS/economicManager');
const economicStabilizer = require('../../UTILS/economicStabilizer');
const antiAbuseSystem = require('../../UTILS/antiAbuseSystem');
const { fmt, fmtFull, getGuildId, sendLogMessage, getEconomicTier, getTierDisplay, calculateDailyInterest, safeSubtract } = require('../../UTILS/common');
const { buildSessionEmbed } = require('../../UTILS/gameSessionKit');
const { ButtonBuilder, ActionRowBuilder, ButtonStyle } = require('discord.js');
const logger = require('../../UTILS/logger');

// Developer ID for special analytics
const DEVELOPER_ID = '466050111680544798';

module.exports = {
    data: new SlashCommandBuilder()
        .setName('economy')
        .setDescription('üìä Complete economy analytics with server overview and detailed economic data')
        .addUserOption(option =>
            option.setName('user')
                .setDescription('User to focus personal analytics on (optional - defaults to you)')
                .setRequired(false)
        ),

    async execute(interaction) {
        const userId = interaction.user.id;
        const targetUser = interaction.options.getUser('user') || interaction.user;
        const targetId = targetUser.id;
        const guildId = (await getGuildId(interaction)) || null;
        const username = targetUser.displayName;

        try {
            await interaction.deferReply();
            logger.info(`Complete economy analytics requested by ${interaction.user.displayName} for ${username}`);
            
            // MEGA DATA COLLECTION - EVERYTHING AT ONCE INCLUDING ECONOMIC SYSTEMS
            const [serverData, personalData, taxationData, gamblingData, economicSystemData] = await Promise.all([
                this.getCompleteServerAnalysis(guildId),
                this.getCompletePersonalAnalysis(targetId, username, guildId),  
                this.getCompleteTaxationAnalysis(guildId),
                this.getCompleteGamblingAnalysis(guildId),
                this.getEconomicSystemData(targetId)
            ]);
            
            // GENERATE COMPREHENSIVE MULTI-PANEL CHART
            const chartBuffer = await this.generateMegaEconomyChart(serverData, personalData, taxationData, gamblingData, targetUser);
            const attachment = new AttachmentBuilder(chartBuffer, { name: 'mega-economy-analysis.png' });

            // BUILD ULTRA-DETAILED EMBED WITH EVERYTHING INCLUDING PAGINATION
            const [megaEmbed, components] = await this.buildMegaEconomyEmbed(serverData, personalData, taxationData, gamblingData, economicSystemData, targetUser, 1);
            
            await interaction.editReply({ embeds: [megaEmbed], files: [attachment], components });

            // LOG THE COMPREHENSIVE ANALYSIS
            await sendLogMessage(
                interaction.client,
                'economy',
                `Complete economy analysis generated by ${interaction.user.displayName} (${userId}) for ${username} - Server: ${serverData.totalUsers} users, ${fmt(serverData.totalWealth)} total wealth`,
                userId,
                guildId
            );

        } catch (error) {
            logger.error(`Error in unified economy command: ${error.message}`);
            
            const errorEmbed = buildSessionEmbed({
                title: '‚ùå Economy Analytics System Error',
                topFields: [
                    { name: 'üîß Critical System Error', value: 'Failed to generate comprehensive economy analytics.' },
                    { name: 'üìã Error Details', value: error.message.substring(0, 150) + '...' },
                    { name: 'üîÑ Retry', value: 'Please try again. If error persists, contact support.' }
                ],
                stageText: 'SYSTEM ERROR',
                color: 0xFF0000,
                footer: 'Unified Economy Analytics System ‚Ä¢ ATIVE Casino'
            });

            await interaction.editReply({ embeds: [errorEmbed] });
        }
    },

    /**
     * Handle button interactions for pagination
     */
    async handleButtonInteraction(interaction, customId) {
        const userId = interaction.user.id;
        
        if (!customId.startsWith('economy_page_')) return;
        
        const page = parseInt(customId.split('_')[2]);
        const targetUser = interaction.user; // For now, always show self on page changes
        const targetId = targetUser.id;
        const guildId = (await getGuildId(interaction)) || null;
        const username = targetUser.displayName;
        
        try {
            await interaction.deferUpdate();
            
            // Re-fetch data for the new page
            const [serverData, personalData, taxationData, gamblingData, economicSystemData] = await Promise.all([
                this.getCompleteServerAnalysis(guildId),
                this.getCompletePersonalAnalysis(targetId, username, guildId),  
                this.getCompleteTaxationAnalysis(guildId),
                this.getCompleteGamblingAnalysis(guildId),
                this.getEconomicSystemData(targetId)
            ]);
            
            const chartBuffer = await this.generateMegaEconomyChart(serverData, personalData, taxationData, gamblingData, targetUser);
            const attachment = new AttachmentBuilder(chartBuffer, { name: 'mega-economy-analysis.png' });
            
            const [megaEmbed, components] = await this.buildMegaEconomyEmbed(serverData, personalData, taxationData, gamblingData, economicSystemData, targetUser, page);
            
            await interaction.editReply({ embeds: [megaEmbed], files: [attachment], components });
            
        } catch (error) {
            logger.error(`Error in economy pagination: ${error.message}`);
        }
    },

    /**
     * GET ECONOMIC SYSTEM DATA
     */
    async getEconomicSystemData(userId) {
        try {
            // DISABLED - Legacy economic system replaced with ChatGPT EconomyGuardian
            // const systemStatus = economicManager.getSystemStatus();
            // const economicReport = await economicManager.getEconomicReport();
            // const userRisk = antiAbuseSystem.getUserRiskAssessment(userId);
            const systemStatus = { status: 'Stable', emergencyMode: false };
            const economicReport = { status: 'Managed by ChatGPT EconomyGuardian', healthScore: 100 };
            const userRisk = { level: 'LOW', score: 0 };
            const multiplierReductions = {};
            
            // DISABLED - Dynamic multipliers now handled by ChatGPT
            const gameTypes = ['blackjack', 'slots', 'roulette', 'crash', 'plinko', 'yahtzee', 'treasurevault'];
            for (const gameType of gameTypes) {
                // Static values - ChatGPT handles dynamic adjustments
                multiplierReductions[gameType] = { 
                    reduction: '0.0', 
                    houseEdgeBonus: '0.00', 
                    effectiveMultiplier: '100.0' 
                };
            }
            
            // Ensure all data fields are populated with accurate information
            const stabilizedData = {
                systemStatus: {
                    initialized: systemStatus?.initialized || false,
                    emergencyMode: systemStatus?.emergencyMode || false,
                    healthScore: systemStatus?.healthScore || 100,
                    lastUpdate: Date.now()
                },
                economicReport: {
                    overview: {
                        emergencyMode: economicReport?.overview?.emergencyMode || systemStatus?.emergencyMode || false,
                        healthScore: economicReport?.overview?.healthScore || systemStatus?.healthScore || 100,
                        systemsOnline: economicReport?.overview?.systemsOnline || systemStatus?.initialized || false
                    },
                    stabilizer: economicReport?.stabilizer || { status: 'UNKNOWN', healthScore: 100 },
                    antiAbuse: economicReport?.antiAbuse || { status: 'MONITORING_ONLY', blockedUsers: 0 },
                    wealthTax: economicReport?.wealthTax || { status: 'ACTIVE' }
                },
                userRisk: {
                    riskLevel: userRisk?.riskLevel || 'LOW',
                    riskScore: userRisk?.riskScore || 0,
                    factors: userRisk?.factors || {},
                    lastAssessment: userRisk?.lastAssessment || Date.now()
                },
                multiplierReductions,
                emergencyMode: systemStatus?.emergencyMode || false,
                healthScore: systemStatus?.healthScore || 100,
                dataComplete: true,
                timestamp: Date.now()
            };

            return stabilizedData;
        } catch (error) {
            logger.error(`Error getting economic system data: ${error.message}`);
            // Return comprehensive fallback data with all required fields
            return {
                systemStatus: { 
                    initialized: false, 
                    emergencyMode: false, 
                    healthScore: 100,
                    lastUpdate: Date.now(),
                    error: error.message 
                },
                economicReport: { 
                    overview: { 
                        emergencyMode: false, 
                        healthScore: 100,
                        systemsOnline: false
                    },
                    stabilizer: { status: 'ERROR', healthScore: 100 },
                    antiAbuse: { status: 'ERROR', blockedUsers: 0 },
                    wealthTax: { status: 'ERROR' }
                },
                userRisk: { 
                    riskLevel: 'UNKNOWN',
                    riskScore: 0,
                    factors: {},
                    lastAssessment: Date.now(),
                    error: 'Risk assessment unavailable'
                },
                multiplierReductions: {
                    blackjack: { reduction: '0.0', houseEdgeBonus: '0.00', effectiveMultiplier: '100.0' },
                    slots: { reduction: '0.0', houseEdgeBonus: '0.00', effectiveMultiplier: '100.0' },
                    roulette: { reduction: '0.0', houseEdgeBonus: '0.00', effectiveMultiplier: '100.0' },
                    crash: { reduction: '0.0', houseEdgeBonus: '0.00', effectiveMultiplier: '100.0' },
                    plinko: { reduction: '0.0', houseEdgeBonus: '0.00', effectiveMultiplier: '100.0' }
                },
                emergencyMode: false,
                healthScore: 100,
                dataComplete: false,
                error: error.message,
                timestamp: Date.now()
            };
        }
    },

    /**
     * GET COMPLETE SERVER-WIDE ECONOMIC ANALYSIS
     * Analyzes ALL users, wealth distribution, activity, economic tiers
     */
    async getCompleteServerAnalysis(guildId) {
        const allUsers = await dbManager.getAllUsers(guildId);
        const users = await this.filterEconomyUsers(allUsers, null); // No interaction for server analysis
        const analysis = {
            totalUsers: users.length,
            totalWealth: 0,
            wealthData: [],
            tierCounts: {},
            activityAnalysis: {
                activeGamblers: 0,
                inactiveUsers: 0,
                totalGamers: 0,
                avgSessionsPerUser: 0
            },
            wealthDistribution: {
                top1Percent: { users: 0, wealth: 0, percentage: 0 },
                top5Percent: { users: 0, wealth: 0, percentage: 0 },
                top10Percent: { users: 0, wealth: 0, percentage: 0 },
                bottom50Percent: { users: 0, wealth: 0, percentage: 0 }
            },
            economicMetrics: {
                giniCoefficient: 0,
                medianWealth: 0,
                averageWealth: 0,
                wealthStandardDeviation: 0
            }
        };

        // Analyze every user comprehensively
        for (const user of users) {
            const balance = await dbManager.getUserBalance(user.user_id, guildId);
            const totalBalance = balance.wallet + balance.bank;
            const tier = getEconomicTier(totalBalance);
            
            analysis.totalWealth += totalBalance;
            analysis.wealthData.push({
                userId: user.user_id,
                username: user.username || 'Unknown',
                balance: totalBalance,
                wallet: balance.wallet,
                bank: balance.bank,
                tier: tier.name,
                tierIndex: this.getTierIndex(tier.name)
            });
            
            // Count tiers
            analysis.tierCounts[tier.name] = (analysis.tierCounts[tier.name] || 0) + 1;
            
            // Activity analysis
            const lastActivity = await dbManager.getUserLastActivity(user.user_id, guildId);
            if (lastActivity && lastActivity.lastGamePlayed) {
                const daysSince = (Date.now() - lastActivity.lastGamePlayed.getTime()) / (24 * 60 * 60 * 1000);
                if (daysSince <= 7) {
                    analysis.activityAnalysis.activeGamblers++;
                } else {
                    analysis.activityAnalysis.inactiveUsers++;
                }
                analysis.activityAnalysis.totalGamers++;
            } else {
                analysis.activityAnalysis.inactiveUsers++;
            }
        }

        // Sort by wealth for distribution analysis
        analysis.wealthData.sort((a, b) => b.balance - a.balance);
        
        // Calculate wealth distribution percentiles
        const totalUsers = analysis.totalUsers;
        const top1Count = Math.max(1, Math.floor(totalUsers * 0.01));
        const top5Count = Math.max(1, Math.floor(totalUsers * 0.05));
        const top10Count = Math.max(1, Math.floor(totalUsers * 0.10));
        const bottom50Count = Math.ceil(totalUsers * 0.50);
        
        analysis.wealthDistribution.top1Percent.users = top1Count;
        analysis.wealthDistribution.top1Percent.wealth = analysis.wealthData.slice(0, top1Count).reduce((sum, u) => sum + u.balance, 0);
        analysis.wealthDistribution.top1Percent.percentage = (analysis.wealthDistribution.top1Percent.wealth / analysis.totalWealth) * 100;
        
        analysis.wealthDistribution.top5Percent.users = top5Count;
        analysis.wealthDistribution.top5Percent.wealth = analysis.wealthData.slice(0, top5Count).reduce((sum, u) => sum + u.balance, 0);
        analysis.wealthDistribution.top5Percent.percentage = (analysis.wealthDistribution.top5Percent.wealth / analysis.totalWealth) * 100;
        
        analysis.wealthDistribution.top10Percent.users = top10Count;
        analysis.wealthDistribution.top10Percent.wealth = analysis.wealthData.slice(0, top10Count).reduce((sum, u) => sum + u.balance, 0);
        analysis.wealthDistribution.top10Percent.percentage = (analysis.wealthDistribution.top10Percent.wealth / analysis.totalWealth) * 100;
        
        analysis.wealthDistribution.bottom50Percent.users = bottom50Count;
        analysis.wealthDistribution.bottom50Percent.wealth = analysis.wealthData.slice(-bottom50Count).reduce((sum, u) => sum + u.balance, 0);
        analysis.wealthDistribution.bottom50Percent.percentage = (analysis.wealthDistribution.bottom50Percent.wealth / analysis.totalWealth) * 100;

        // Calculate economic metrics
        analysis.economicMetrics.averageWealth = analysis.totalWealth / totalUsers;
        analysis.economicMetrics.medianWealth = analysis.wealthData[Math.floor(totalUsers / 2)]?.balance || 0;
        
        // Calculate wealth inequality (simplified Gini coefficient approximation)
        const wealthArray = analysis.wealthData.map(u => u.balance).sort((a, b) => a - b);
        let giniSum = 0;
        for (let i = 0; i < wealthArray.length; i++) {
            giniSum += (2 * i + 1 - wealthArray.length) * wealthArray[i];
        }
        analysis.economicMetrics.giniCoefficient = giniSum / (wealthArray.length * wealthArray.reduce((sum, w) => sum + w, 0));
        
        // Standard deviation
        const avgWealth = analysis.economicMetrics.averageWealth;
        const variance = wealthArray.reduce((sum, w) => sum + Math.pow(w - avgWealth, 2), 0) / wealthArray.length;
        analysis.economicMetrics.wealthStandardDeviation = Math.sqrt(variance);

        return analysis;
    },

    /**
     * GET COMPLETE PERSONAL ANALYSIS FOR TARGET USER
     * Deep dive into individual user's economy, gambling patterns, risk assessment
     */
    async getCompletePersonalAnalysis(userId, username, guildId) {
        await dbManager.ensureUser(userId, username);
        
        const analysis = {
            userId,
            username,
            isOffEconomy: userId === DEVELOPER_ID,
            balance: await dbManager.getUserBalance(userId, guildId),
            tier: null,
            wealthMetrics: {},
            gamblingAnalysis: {},
            riskAssessment: {},
            taxStatus: {},
            shopAnalysis: {},
            economicHistory: {},
            performanceMetrics: {}
        };

        // Basic wealth analysis
        const totalBalance = analysis.balance.wallet + analysis.balance.bank;
        analysis.tier = getEconomicTier(totalBalance);
        analysis.wealthMetrics = {
            totalWealth: totalBalance,
            walletPercent: totalBalance > 0 ? (analysis.balance.wallet / totalBalance) * 100 : 0,
            bankPercent: totalBalance > 0 ? (analysis.balance.bank / totalBalance) * 100 : 0,
            dailyInterest: calculateDailyInterest(analysis.balance.bank, totalBalance),
            tierName: analysis.tier.name,
            tierDisplay: getTierDisplay(totalBalance)
        };

        // Comprehensive gambling analysis
        analysis.gamblingAnalysis = await this.getDetailedGamblingAnalysis(userId, guildId);
        
        // Risk assessment
        analysis.riskAssessment = this.calculateComprehensiveRisk(analysis.gamblingAnalysis, totalBalance);
        
        // Tax status analysis
        if (!analysis.isOffEconomy) {
            analysis.taxStatus = await wealthTaxManager.getUserWealthTaxStatus(userId, guildId);
        }
        
        // Shop analysis
        analysis.shopAnalysis = await this.getShopAnalytics(userId);
        
        // Performance metrics
        analysis.performanceMetrics = this.calculatePerformanceMetrics(analysis.gamblingAnalysis, totalBalance);

        return analysis;
    },

    /**
     * GET COMPLETE TAXATION ANALYSIS FOR SERVER
     * Comprehensive wealth tax analysis, projections, bracket distributions
     */
    async getCompleteTaxationAnalysis(guildId) {
        const taxSummary = await wealthTaxManager.getWealthTaxSummary(guildId, 100);
        
        if (!taxSummary) {
            return {
                error: 'Unable to generate taxation analysis',
                summary: { wealthyUsers: 0, taxableUsers: 0, potentialTaxRevenue: 0 },
                userStatuses: []
            };
        }

        const analysis = {
            summary: taxSummary.summary,
            userStatuses: taxSummary.userStatuses,
            bracketAnalysis: {},
            taxEfficiency: {},
            projections: {},
            behaviorAnalysis: {}
        };

        // Enhanced bracket analysis
        for (const [bracket, data] of Object.entries(analysis.summary.bracketBreakdown)) {
            analysis.bracketAnalysis[bracket] = {
                ...data,
                averageTaxPerUser: data.taxable > 0 ? data.taxRevenue / data.taxable : 0,
                taxablePercentage: data.count > 0 ? (data.taxable / data.count) * 100 : 0,
                avoidanceRate: data.count > 0 ? ((data.count - data.taxable) / data.count) * 100 : 0
            };
        }

        // Tax efficiency metrics
        const totalWealthyUsers = analysis.summary.wealthyUsers;
        const totalTaxableUsers = analysis.summary.taxableUsers;
        analysis.taxEfficiency = {
            collectionRate: totalWealthyUsers > 0 ? (totalTaxableUsers / totalWealthyUsers) * 100 : 0,
            avoidanceRate: totalWealthyUsers > 0 ? ((totalWealthyUsers - totalTaxableUsers) / totalWealthyUsers) * 100 : 0,
            revenuePerWealthyUser: totalWealthyUsers > 0 ? analysis.summary.potentialTaxRevenue / totalWealthyUsers : 0,
            revenuePerTaxableUser: totalTaxableUsers > 0 ? analysis.summary.potentialTaxRevenue / totalTaxableUsers : 0
        };

        // Behavior analysis
        analysis.behaviorAnalysis = {
            highStakesGamblersPercent: totalWealthyUsers > 0 ? (analysis.summary.highStakesGamblers / totalWealthyUsers) * 100 : 0,
            inactiveRichPercent: totalWealthyUsers > 0 ? (analysis.summary.inactiveRich / totalWealthyUsers) * 100 : 0,
            taxMotivatedGambling: analysis.summary.highStakesGamblers // Users potentially gambling to avoid taxes
        };

        return analysis;
    },

    /**
     * GET COMPLETE GAMBLING ANALYSIS FOR SERVER  
     * Comprehensive gambling statistics, patterns, game analysis
     */
    async getCompleteGamblingAnalysis(guildId) {
        const allUsers = await dbManager.getAllUsers(guildId);
        const users = await this.filterEconomyUsers(allUsers, null); // No interaction for server analysis
        const gameTypes = [
            'blackjack', 'slots', 'multi-slots', 'crash', 'duck', 'fishing',
            'plinko', 'rps', 'bingo', 'battleship', 'uno', 'roulette',
            'treasurevault', 'yahtzee', 'heist', 'lottery'
        ];

        const analysis = {
            overview: {
                totalGames: 0,
                totalWagered: 0,
                totalWon: 0,
                totalPlayers: 0,
                houseEdge: 0,
                biggestWin: 0,
                biggestLoss: 0
            },
            gameBreakdown: {},
            playerAnalysis: {
                mostActivePlayer: null,
                biggestWinner: null,
                biggestLoser: null,
                highestROI: null,
                lowestROI: null
            },
            patterns: {
                popularityRanking: [],
                profitabilityRanking: [],
                riskLevels: {}
            },
            economicImpact: {
                moneyCirculation: 0,
                wealthRedistribution: 0,
                houseAdvantage: 0
            }
        };

        const playerStats = {};

        // Analyze all games and players
        for (const user of users) {
            let userTotalGames = 0;
            let userTotalWagered = 0;
            let userTotalWon = 0;
            let userBiggestWin = 0;
            let userBiggestLoss = 0;
            
            playerStats[user.user_id] = {
                username: user.username || 'Unknown',
                totalGames: 0,
                totalWagered: 0,
                totalWon: 0,
                netProfit: 0,
                roi: 0,
                favoriteGame: null,
                riskLevel: 'UNKNOWN'
            };
            
            for (const gameType of gameTypes) {
                const stats = await dbManager.getUserStats(user.user_id, guildId, gameType);
                if (stats) {
                    const games = (stats.wins || 0) + (stats.losses || 0);
                    const wagered = stats.total_wagered || 0;
                    const won = stats.total_won || 0;
                    const biggestWin = stats.biggest_win || 0;
                    const biggestLoss = Math.abs(stats.biggest_loss || 0);
                    
                    if (games > 0) {
                        // User stats
                        userTotalGames += games;
                        userTotalWagered += wagered;
                        userTotalWon += won;
                        
                        if (biggestWin > userBiggestWin) userBiggestWin = biggestWin;
                        if (biggestLoss > userBiggestLoss) userBiggestLoss = biggestLoss;
                        
                        // Global stats
                        analysis.overview.totalGames += games;
                        analysis.overview.totalWagered += wagered;
                        analysis.overview.totalWon += won;
                        
                        if (biggestWin > analysis.overview.biggestWin) {
                            analysis.overview.biggestWin = biggestWin;
                        }
                        if (biggestLoss > analysis.overview.biggestLoss) {
                            analysis.overview.biggestLoss = biggestLoss;
                        }
                        
                        // Game breakdown
                        if (!analysis.gameBreakdown[gameType]) {
                            analysis.gameBreakdown[gameType] = {
                                games: 0,
                                wagered: 0,
                                won: 0,
                                players: 0,
                                houseEdge: 0,
                                averageBet: 0,
                                winRate: 0,
                                popularity: 0,
                                rtp: 0
                            };
                        }
                        
                        analysis.gameBreakdown[gameType].games += games;
                        analysis.gameBreakdown[gameType].wagered += wagered;
                        analysis.gameBreakdown[gameType].won += won;
                        analysis.gameBreakdown[gameType].players++;
                    }
                }
            }
            
            if (userTotalGames > 0) {
                analysis.overview.totalPlayers++;
                
                playerStats[user.user_id].totalGames = userTotalGames;
                playerStats[user.user_id].totalWagered = userTotalWagered;
                playerStats[user.user_id].totalWon = userTotalWon;
                playerStats[user.user_id].netProfit = userTotalWon - userTotalWagered;
                playerStats[user.user_id].roi = userTotalWagered > 0 ? ((userTotalWon - userTotalWagered) / userTotalWagered) * 100 : 0;
                
                // Track extremes
                if (!analysis.playerAnalysis.mostActivePlayer || userTotalGames > analysis.playerAnalysis.mostActivePlayer.games) {
                    analysis.playerAnalysis.mostActivePlayer = {
                        username: user.username || 'Unknown',
                        games: userTotalGames,
                        wagered: userTotalWagered,
                        won: userTotalWon
                    };
                }
                
                const netProfit = userTotalWon - userTotalWagered;
                if (!analysis.playerAnalysis.biggestWinner || netProfit > analysis.playerAnalysis.biggestWinner.profit) {
                    analysis.playerAnalysis.biggestWinner = {
                        username: user.username || 'Unknown',
                        profit: netProfit,
                        wagered: userTotalWagered,
                        roi: userTotalWagered > 0 ? (netProfit / userTotalWagered) * 100 : 0
                    };
                }
                
                if (!analysis.playerAnalysis.biggestLoser || netProfit < analysis.playerAnalysis.biggestLoser.loss) {
                    analysis.playerAnalysis.biggestLoser = {
                        username: user.username || 'Unknown',
                        loss: Math.abs(netProfit),
                        wagered: userTotalWagered,
                        roi: userTotalWagered > 0 ? (netProfit / userTotalWagered) * 100 : 0
                    };
                }
            }
        }

        // Calculate game metrics
        for (const [gameType, gameData] of Object.entries(analysis.gameBreakdown)) {
            gameData.houseEdge = gameData.wagered > 0 ? ((gameData.wagered - gameData.won) / gameData.wagered) * 100 : 0;
            gameData.averageBet = gameData.games > 0 ? gameData.wagered / gameData.games : 0;
            gameData.winRate = gameData.wagered > 0 ? (gameData.won / gameData.wagered) * 100 : 0;
            gameData.rtp = 100 - gameData.houseEdge; // Return to Player
            gameData.popularity = (gameData.games / analysis.overview.totalGames) * 100;
        }

        // Overall house edge
        analysis.overview.houseEdge = analysis.overview.totalWagered > 0 ? 
            ((analysis.overview.totalWagered - analysis.overview.totalWon) / analysis.overview.totalWagered) * 100 : 0;

        // Create rankings
        analysis.patterns.popularityRanking = Object.entries(analysis.gameBreakdown)
            .sort((a, b) => b[1].games - a[1].games)
            .map(([game, data]) => ({ game, games: data.games, popularity: data.popularity.toFixed(1) }));

        analysis.patterns.profitabilityRanking = Object.entries(analysis.gameBreakdown)
            .sort((a, b) => b[1].houseEdge - a[1].houseEdge)
            .map(([game, data]) => ({ game, houseEdge: data.houseEdge.toFixed(2), rtp: data.rtp.toFixed(2) }));

        return analysis;
    },

    /**
     * GET DETAILED GAMBLING ANALYSIS FOR INDIVIDUAL USER
     */
    async getDetailedGamblingAnalysis(userId, guildId) {
        const gameTypes = [
            'blackjack', 'slots', 'multi-slots', 'crash', 'duck', 'fishing',
            'plinko', 'rps', 'bingo', 'battleship', 'uno', 'roulette',
            'treasurevault', 'yahtzee', 'heist', 'lottery'
        ];

        const analysis = {
            totalWins: 0,
            totalLosses: 0,
            totalGames: 0,
            totalWagered: 0,
            totalWon: 0,
            biggestWin: 0,
            biggestLoss: 0,
            winRate: 0,
            avgBet: 0,
            netProfit: 0,
            roi: 0,
            favoriteGames: [],
            gamePerformance: {},
            streakAnalysis: {},
            bettingPatterns: {}
        };

        for (const gameType of gameTypes) {
            const stats = await dbManager.getUserStats(userId, guildId, gameType);
            if (stats) {
                const wins = stats.wins || 0;
                const losses = stats.losses || 0;
                const games = wins + losses;
                const wagered = stats.total_wagered || 0;
                const won = stats.total_won || 0;
                
                if (games > 0) {
                    analysis.totalWins += wins;
                    analysis.totalLosses += losses;
                    analysis.totalWagered += wagered;
                    analysis.totalWon += won;
                    
                    if (stats.biggest_win > analysis.biggestWin) {
                        analysis.biggestWin = stats.biggest_win;
                    }
                    if (Math.abs(stats.biggest_loss) > Math.abs(analysis.biggestLoss)) {
                        analysis.biggestLoss = stats.biggest_loss;
                    }
                    
                    analysis.favoriteGames.push({
                        name: gameType,
                        gamesPlayed: games,
                        winRate: ((wins / games) * 100).toFixed(1),
                        wagered: wagered,
                        won: won,
                        netProfit: won - wagered,
                        roi: wagered > 0 ? ((won - wagered) / wagered) * 100 : 0,
                        avgBet: wagered / games
                    });
                    
                    analysis.gamePerformance[gameType] = {
                        winRate: (wins / games) * 100,
                        profitability: won - wagered,
                        efficiency: wagered > 0 ? (won / wagered) : 0
                    };
                }
            }
        }

        analysis.totalGames = analysis.totalWins + analysis.totalLosses;
        analysis.winRate = analysis.totalGames > 0 ? (analysis.totalWins / analysis.totalGames) * 100 : 0;
        analysis.avgBet = analysis.totalGames > 0 ? analysis.totalWagered / analysis.totalGames : 0;
        analysis.netProfit = analysis.totalWon - analysis.totalWagered;
        analysis.roi = analysis.totalWagered > 0 ? (analysis.netProfit / analysis.totalWagered) * 100 : 0;

        // Sort favorite games by play count
        analysis.favoriteGames.sort((a, b) => b.gamesPlayed - a.gamesPlayed);

        return analysis;
    },

    /**
     * CALCULATE COMPREHENSIVE RISK ASSESSMENT
     */
    calculateComprehensiveRisk(gamblingAnalysis, totalBalance) {
        const analysis = {
            overallRiskLevel: 'NO DATA',
            riskScore: 0,
            factors: {
                betSizeRisk: 'LOW',
                frequencyRisk: 'LOW', 
                volatilityRisk: 'LOW',
                concentrationRisk: 'LOW'
            },
            warnings: [],
            recommendations: []
        };

        if (gamblingAnalysis.avgBet === 0 || totalBalance === 0) {
            return analysis;
        }

        const betToWealthRatio = gamblingAnalysis.avgBet / totalBalance;
        const lossToWealthRatio = Math.abs(gamblingAnalysis.biggestLoss) / totalBalance;
        const volatility = gamblingAnalysis.totalGames > 0 ? 
            (gamblingAnalysis.biggestWin + Math.abs(gamblingAnalysis.biggestLoss)) / gamblingAnalysis.avgBet : 0;

        // Bet Size Risk
        if (betToWealthRatio > 0.1) analysis.factors.betSizeRisk = 'EXTREME';
        else if (betToWealthRatio > 0.05) analysis.factors.betSizeRisk = 'HIGH';
        else if (betToWealthRatio > 0.02) analysis.factors.betSizeRisk = 'MODERATE';
        else if (betToWealthRatio > 0.01) analysis.factors.betSizeRisk = 'LOW';
        else analysis.factors.betSizeRisk = 'CONSERVATIVE';

        // Frequency Risk
        const gamesPerDay = gamblingAnalysis.totalGames / 30; // Assuming 30-day period
        if (gamesPerDay > 50) analysis.factors.frequencyRisk = 'EXTREME';
        else if (gamesPerDay > 20) analysis.factors.frequencyRisk = 'HIGH';
        else if (gamesPerDay > 10) analysis.factors.frequencyRisk = 'MODERATE';
        else analysis.factors.frequencyRisk = 'LOW';

        // Volatility Risk
        if (volatility > 100) analysis.factors.volatilityRisk = 'EXTREME';
        else if (volatility > 50) analysis.factors.volatilityRisk = 'HIGH';
        else if (volatility > 20) analysis.factors.volatilityRisk = 'MODERATE';
        else analysis.factors.volatilityRisk = 'LOW';

        // Calculate overall risk score (0-100)
        const riskFactors = {
            'CONSERVATIVE': 0, 'LOW': 20, 'MODERATE': 40, 'HIGH': 60, 'EXTREME': 80
        };
        
        analysis.riskScore = Math.round((
            (riskFactors[analysis.factors.betSizeRisk] || 0) * 0.4 +
            (riskFactors[analysis.factors.frequencyRisk] || 0) * 0.3 +
            (riskFactors[analysis.factors.volatilityRisk] || 0) * 0.3
        ));

        if (analysis.riskScore >= 70) analysis.overallRiskLevel = 'üî¥ EXTREME';
        else if (analysis.riskScore >= 50) analysis.overallRiskLevel = 'üü† HIGH';
        else if (analysis.riskScore >= 30) analysis.overallRiskLevel = 'üü° MODERATE';
        else if (analysis.riskScore >= 10) analysis.overallRiskLevel = 'üü¢ LOW';
        else analysis.overallRiskLevel = 'üîµ CONSERVATIVE';

        // Generate warnings and recommendations
        if (betToWealthRatio > 0.05) {
            analysis.warnings.push('Betting more than 5% of wealth per game');
            analysis.recommendations.push('Consider reducing bet sizes to preserve wealth');
        }
        
        if (gamblingAnalysis.roi < -50) {
            analysis.warnings.push('Significant gambling losses detected');
            analysis.recommendations.push('Consider taking a break or setting loss limits');
        }

        return analysis;
    },

    /**
     * CALCULATE PERFORMANCE METRICS
     */
    calculatePerformanceMetrics(gamblingAnalysis, totalBalance) {
        return {
            profitabilityScore: gamblingAnalysis.roi > 0 ? Math.min(gamblingAnalysis.roi, 100) : Math.max(gamblingAnalysis.roi, -100),
            consistencyScore: gamblingAnalysis.totalGames > 0 ? 
                100 - Math.min((Math.abs(gamblingAnalysis.biggestWin - gamblingAnalysis.avgBet) / gamblingAnalysis.avgBet * 100), 100) : 0,
            experienceLevel: this.calculateExperienceLevel(gamblingAnalysis.totalGames),
            gamingEfficiency: gamblingAnalysis.totalWagered > 0 ? (gamblingAnalysis.totalWon / gamblingAnalysis.totalWagered) * 100 : 0
        };
    },

    /**
     * CALCULATE EXPERIENCE LEVEL
     */
    calculateExperienceLevel(totalGames) {
        if (totalGames >= 10000) return 'LEGENDARY';
        if (totalGames >= 5000) return 'EXPERT';
        if (totalGames >= 1000) return 'EXPERIENCED';
        if (totalGames >= 100) return 'INTERMEDIATE';
        if (totalGames >= 10) return 'BEGINNER';
        return 'NOVICE';
    },

    /**
     * GET SHOP ANALYTICS
     */
    async getShopAnalytics(userId) {
        // Integration with shop system - placeholder for now
        return {
            totalPurchases: 0,
            totalSpent: 0,
            activeBoosts: 0,
            favoriteCategory: 'None'
        };
    },

    /**
     * GET TIER INDEX FOR SORTING
     */
    getTierIndex(tierName) {
        const tiers = ['Broke', 'Poor', 'Working Class', 'Middle Class', 'Upper Class', 'Rich', 'Very Rich', 'Ultra Rich', 'Mega Rich', 'Billionaire'];
        return tiers.indexOf(tierName);
    },

    /**
     * BUILD MEGA COMPREHENSIVE ECONOMY EMBED WITH PAGINATION
     */
    async buildMegaEconomyEmbed(serverData, personalData, taxationData, gamblingData, economicSystemData, targetUser, page = 1) {
        const isOffEconomy = personalData.isOffEconomy;
        const totalPages = 4; // Overview, Personal, Economic Systems, Game Analysis
        
        // Calculate comprehensive metrics
        const serverMetrics = {
            wealthInequality: serverData.economicMetrics.giniCoefficient.toFixed(3),
            economicHealth: this.calculateEconomicHealth(serverData),
            activityRate: ((serverData.activityAnalysis.activeGamblers / serverData.totalUsers) * 100).toFixed(1)
        };

        const personalMetrics = {
            wealthRank: this.calculateWealthRank(personalData, serverData),
            performanceGrade: this.calculatePerformanceGrade(personalData.performanceMetrics),
            riskStatus: personalData.riskAssessment.overallRiskLevel
        };

        let topFields = [];
        let bankFields = [];
        let title = '';
        let stageText = '';

        // PAGE-SPECIFIC CONTENT
        switch (page) {
            case 1: // OVERVIEW PAGE
                title = `üìä ECONOMY OVERVIEW ${isOffEconomy ? '(üëë DEVELOPER)' : ''}`;
                stageText = 'SERVER OVERVIEW';
                
                topFields = [
                    {
                        name: 'üåç SERVER ECONOMY OVERVIEW',
                        value: `**Total Users:** ${serverData.totalUsers.toLocaleString()}\n` +
                               `**Total Wealth:** ${fmt(serverData.totalWealth)}\n` +
                               `**Wealth Inequality (Gini):** ${serverMetrics.wealthInequality}\n` +
                               `**Economic Health:** ${serverMetrics.economicHealth}\n` +
                               `**Activity Rate:** ${serverMetrics.activityRate}%`,
                        inline: false
                    },
                    {
                        name: 'üìä WEALTH DISTRIBUTION',
                        value: `**Top 1%:** ${serverData.wealthDistribution.top1Percent.users} users (${serverData.wealthDistribution.top1Percent.percentage.toFixed(1)}% wealth)\n` +
                               `**Top 5%:** ${serverData.wealthDistribution.top5Percent.users} users (${serverData.wealthDistribution.top5Percent.percentage.toFixed(1)}% wealth)\n` +
                               `**Top 10%:** ${serverData.wealthDistribution.top10Percent.users} users (${serverData.wealthDistribution.top10Percent.percentage.toFixed(1)}% wealth)\n` +
                               `**Bottom 50%:** ${serverData.wealthDistribution.bottom50Percent.users} users (${serverData.wealthDistribution.bottom50Percent.percentage.toFixed(1)}% wealth)`,
                        inline: true
                    },
                    {
                        name: 'üéÆ GAMBLING OVERVIEW',
                        value: `**Total Games:** ${gamblingData.overview.totalGames.toLocaleString()}\n` +
                               `**Total Wagered:** ${fmt(gamblingData.overview.totalWagered)}\n` +
                               `**House Edge:** ${gamblingData.overview.houseEdge.toFixed(2)}%\n` +
                               `**Active Gamblers:** ${gamblingData.overview.totalPlayers}\n` +
                               `**Biggest Win:** ${fmt(gamblingData.overview.biggestWin)}`,
                        inline: true
                    },
                    {
                        name: 'üí∏ TAXATION OVERVIEW',
                        value: `**Wealthy Users:** ${taxationData.summary.wealthyUsers}\n` +
                               `**Taxable Users:** ${taxationData.summary.taxableUsers}\n` +
                               `**Tax Avoidance:** ${taxationData.taxEfficiency.avoidanceRate.toFixed(1)}%\n` +
                               `**Potential Revenue:** ${fmt(taxationData.summary.potentialTaxRevenue)}\n` +
                               `**Collection Rate:** ${taxationData.taxEfficiency.collectionRate.toFixed(1)}%`,
                        inline: false
                    }
                ];
                
                bankFields = [
                    { name: 'üíé Total Wealth', value: fmt(serverData.totalWealth), inline: true },
                    { name: 'üè† House Edge', value: `${gamblingData.overview.houseEdge.toFixed(2)}%`, inline: true },
                    { name: 'üéØ Activity Rate', value: `${serverMetrics.activityRate}%`, inline: true }
                ];
                break;

            case 2: // PERSONAL ANALYTICS PAGE
                title = `üë§ ${personalData.username.toUpperCase()}'S ANALYTICS`;
                stageText = 'PERSONAL ANALYSIS';
                
                topFields = [
                    {
                        name: `üí∞ ${personalData.username.toUpperCase()}'S WEALTH`,
                        value: `**Net Worth:** ${fmt(personalData.wealthMetrics.totalWealth)}\n` +
                               `**Wallet:** ${fmt(personalData.balance.wallet)} (${personalData.wealthMetrics.walletPercent.toFixed(1)}%)\n` +
                               `**Bank:** ${fmt(personalData.balance.bank)} (${personalData.wealthMetrics.bankPercent.toFixed(1)}%)\n` +
                               `**Daily Interest:** ${fmt(personalData.wealthMetrics.dailyInterest)}\n` +
                               `**Wealth Rank:** ${personalMetrics.wealthRank}`,
                        inline: false
                    },
                    {
                        name: 'üé∞ GAMBLING PERFORMANCE',
                        value: `**Total Games:** ${personalData.gamblingAnalysis.totalGames.toLocaleString()}\n` +
                               `**Win Rate:** ${personalData.gamblingAnalysis.winRate.toFixed(1)}%\n` +
                               `**Net Profit:** ${personalData.gamblingAnalysis.netProfit >= 0 ? '+' : ''}${fmt(personalData.gamblingAnalysis.netProfit)}\n` +
                               `**ROI:** ${personalData.gamblingAnalysis.roi.toFixed(2)}%\n` +
                               `**Experience:** ${this.calculateExperienceLevel(personalData.gamblingAnalysis.totalGames)}`,
                        inline: true
                    },
                    {
                        name: 'üéØ RISK ASSESSMENT',
                        value: `**Risk Level:** ${personalMetrics.riskStatus}\n` +
                               `**Risk Score:** ${personalData.riskAssessment.riskScore}/100\n` +
                               `**Bet Size Risk:** ${personalData.riskAssessment.factors.betSizeRisk}\n` +
                               `**Frequency Risk:** ${personalData.riskAssessment.factors.frequencyRisk}\n` +
                               `**Performance:** ${personalMetrics.performanceGrade}`,
                        inline: true
                    }
                ];

                // Add top games
                if (personalData.gamblingAnalysis.favoriteGames.length > 0) {
                    const topGames = personalData.gamblingAnalysis.favoriteGames.slice(0, 5).map(game => 
                        `**${game.name}:** ${game.gamesPlayed} games (${game.winRate}% WR, ${game.roi.toFixed(1)}% ROI)`
                    ).join('\n');
                    
                    topFields.push({
                        name: 'üèÜ TOP GAMES BY VOLUME',
                        value: topGames,
                        inline: false
                    });
                }

                // Add tax status
                if (!isOffEconomy && personalData.taxStatus && Object.keys(personalData.taxStatus).length > 0) {
                    const taxInfo = personalData.taxStatus.isSubjectToTax 
                        ? `‚ö†Ô∏è **TAXABLE:** ${fmt(personalData.taxStatus.taxAmount)} potential tax`
                        : `‚úÖ **EXEMPT:** ${personalData.taxStatus.reason.replace(/_/g, ' ')}`;
                    
                    topFields.push({
                        name: 'üí∞ TAX STATUS',
                        value: `**Bracket:** ${personalData.taxStatus.bracket || 'N/A'}\n` +
                               `${taxInfo}\n` +
                               `**High Stakes:** ${personalData.taxStatus.bettingAnalysis?.hasHighStakes ? 'Yes' : 'No'}`,
                        inline: true
                    });
                }
                
                bankFields = [
                    { name: 'üí∞ Net Worth', value: fmt(personalData.wealthMetrics.totalWealth), inline: true },
                    { name: 'üìà Personal ROI', value: `${personalData.gamblingAnalysis.roi.toFixed(2)}%`, inline: true },
                    { name: 'üéØ Risk Score', value: `${personalData.riskAssessment.riskScore}/100`, inline: true }
                ];
                break;

            case 3: // ECONOMIC SYSTEMS PAGE
                title = '‚öôÔ∏è ECONOMIC SYSTEMS STATUS';
                stageText = 'ECONOMIC CONTROLS';
                
                const emergencyStatus = economicSystemData.emergencyMode ? 'üö® ACTIVE' : '‚úÖ NORMAL';
                const healthColor = economicSystemData.healthScore >= 80 ? 'üü¢' : 
                                   economicSystemData.healthScore >= 60 ? 'üü°' : 'üî¥';
                
                topFields = [
                    {
                        name: 'üõ°Ô∏è SYSTEM STATUS',
                        value: `**Emergency Mode:** ${emergencyStatus}\n` +
                               `**Health Score:** ${healthColor} ${economicSystemData.healthScore}/100\n` +
                               `**Systems Online:** ${economicSystemData.systemStatus.initialized ? '‚úÖ' : '‚ùå'}\n` +
                               `**User Risk Level:** ${economicSystemData.userRisk.riskLevel}\n` +
                               `**Anti-Abuse Active:** ‚úÖ Monitoring`,
                        inline: false
                    },
                    {
                        name: 'üéÆ DYNAMIC MULTIPLIER REDUCTIONS',
                        value: Object.entries(economicSystemData.multiplierReductions).slice(0, 4).map(([game, data]) => 
                            `**${game.toUpperCase()}:** -${data.reduction}% (${data.effectiveMultiplier}% effective)`
                        ).join('\n'),
                        inline: true
                    },
                    {
                        name: 'üè† HOUSE EDGE ADJUSTMENTS',
                        value: Object.entries(economicSystemData.multiplierReductions).slice(0, 4).map(([game, data]) => 
                            `**${game.toUpperCase()}:** +${data.houseEdgeBonus}% bonus edge`
                        ).join('\n'),
                        inline: true
                    }
                ];

                // Add comprehensive tips and recommendations based on system status
                const tips = this.generateEconomyTips(economicSystemData);
                topFields.push({
                    name: 'üí° ECONOMY MANAGEMENT TIPS',
                    value: tips,
                    inline: false
                });
                
                // Add remaining games if more than 4
                if (Object.keys(economicSystemData.multiplierReductions).length > 4) {
                    const remainingGames = Object.entries(economicSystemData.multiplierReductions).slice(4);
                    topFields.push({
                        name: 'üéØ MORE GAME ADJUSTMENTS',
                        value: remainingGames.map(([game, data]) => 
                            `**${game.toUpperCase()}:** -${data.reduction}% multiplier, +${data.houseEdgeBonus}% edge`
                        ).join('\n'),
                        inline: false
                    });
                }
                
                bankFields = [
                    { name: 'üõ°Ô∏è Health Score', value: `${economicSystemData.healthScore}/100`, inline: true },
                    { name: 'üö® Emergency Mode', value: economicSystemData.emergencyMode ? 'Active' : 'Normal', inline: true },
                    { name: 'üë§ Your Risk', value: economicSystemData.userRisk.riskLevel, inline: true }
                ];
                break;

            case 4: // DETAILED GAME ANALYSIS PAGE
                title = 'üéÆ DETAILED GAME ANALYSIS';
                stageText = 'GAME STATISTICS';
                
                // Server gambling leaders
                topFields = [
                    {
                        name: 'üëë SERVER GAMBLING LEADERS',
                        value: `**Most Active:** ${gamblingData.playerAnalysis.mostActivePlayer?.username || 'None'} (${gamblingData.playerAnalysis.mostActivePlayer?.games.toLocaleString() || '0'} games)\n` +
                               `**Biggest Winner:** ${gamblingData.playerAnalysis.biggestWinner?.username || 'None'} (${gamblingData.playerAnalysis.biggestWinner ? '+' + fmt(gamblingData.playerAnalysis.biggestWinner.profit) : 'N/A'})\n` +
                               `**Biggest Loser:** ${gamblingData.playerAnalysis.biggestLoser?.username || 'None'} (-${fmt(gamblingData.playerAnalysis.biggestLoser?.loss || 0)})`,
                        inline: false
                    },
                    {
                        name: 'üìä GAME POPULARITY RANKING',
                        value: gamblingData.patterns.popularityRanking.slice(0, 5).map((game, i) => 
                            `**${i + 1}. ${game.game.toUpperCase()}:** ${game.games.toLocaleString()} games (${game.popularity}%)`
                        ).join('\n'),
                        inline: true
                    },
                    {
                        name: 'üè† HOUSE EDGE BY GAME',
                        value: gamblingData.patterns.profitabilityRanking.slice(0, 5).map((game, i) => 
                            `**${i + 1}. ${game.game.toUpperCase()}:** ${game.houseEdge}% edge (${game.rtp}% RTP)`
                        ).join('\n'),
                        inline: true
                    }
                ];

                // Add detailed game breakdown
                const topGames = Object.entries(gamblingData.gameBreakdown)
                    .sort((a, b) => b[1].games - a[1].games)
                    .slice(0, 3);
                
                topGames.forEach(([gameType, gameData]) => {
                    topFields.push({
                        name: `üéØ ${gameType.toUpperCase()} DETAILED STATS`,
                        value: `**Games Played:** ${gameData.games.toLocaleString()}\n` +
                               `**Total Wagered:** ${fmt(gameData.wagered)}\n` +
                               `**Total Won:** ${fmt(gameData.won)}\n` +
                               `**Players:** ${gameData.players}\n` +
                               `**House Edge:** ${gameData.houseEdge.toFixed(2)}%\n` +
                               `**Average Bet:** ${fmt(gameData.averageBet)}`,
                        inline: true
                    });
                });
                
                bankFields = [
                    { name: 'üéÆ Total Games', value: gamblingData.overview.totalGames.toLocaleString(), inline: true },
                    { name: 'üí∞ Total Wagered', value: fmt(gamblingData.overview.totalWagered), inline: true },
                    { name: 'üè† Overall Edge', value: `${gamblingData.overview.houseEdge.toFixed(2)}%`, inline: true }
                ];
                break;
        }

        // Create pagination buttons
        const components = [];
        if (totalPages > 1) {
            const row = new ActionRowBuilder();
            
            // Previous button
            if (page > 1) {
                row.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`economy_page_${page - 1}`)
                        .setLabel('‚óÄÔ∏è Previous')
                        .setStyle(ButtonStyle.Secondary)
                );
            }
            
            // Page indicator
            row.addComponents(
                new ButtonBuilder()
                    .setCustomId(`economy_page_info`)
                    .setLabel(`Page ${page}/${totalPages}`)
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(true)
            );
            
            // Next button
            if (page < totalPages) {
                row.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`economy_page_${page + 1}`)
                        .setLabel('Next ‚ñ∂Ô∏è')
                        .setStyle(ButtonStyle.Secondary)
                );
            }
            
            components.push(row);
        }

        const embed = buildSessionEmbed({
            title,
            topFields,
            bankFields,
            stageText,
            color: isOffEconomy ? 0x9B59B6 : (personalData.wealthMetrics.totalWealth >= 1000000 ? 0xFFD700 : 0x00FF00),
            footer: `üîç Economy Analytics ‚Ä¢ Page ${page}/${totalPages} ‚Ä¢ ${personalData.username} Focus`,
            image: 'attachment://mega-economy-analysis.png'
        });

        return [embed, components];
    },

    /**
     * CALCULATE ECONOMIC HEALTH SCORE
     */
    calculateEconomicHealth(serverData) {
        // Simple health calculation based on activity, wealth distribution, and participation
        const activityScore = (serverData.activityAnalysis.activeGamblers / serverData.totalUsers) * 100;
        const equalityScore = (1 - serverData.economicMetrics.giniCoefficient) * 100;
        const participationScore = (serverData.activityAnalysis.totalGamers / serverData.totalUsers) * 100;
        
        const healthScore = (activityScore * 0.4 + equalityScore * 0.3 + participationScore * 0.3);
        
        if (healthScore >= 80) return 'üü¢ EXCELLENT';
        if (healthScore >= 60) return 'üü° GOOD';
        if (healthScore >= 40) return 'üü† FAIR';
        return 'üî¥ POOR';
    },

    /**
     * CALCULATE WEALTH RANK
     */
    calculateWealthRank(personalData, serverData) {
        const userBalance = personalData.wealthMetrics.totalWealth;
        let rank = 1;
        
        for (const userData of serverData.wealthData) {
            if (userData.balance > userBalance) {
                rank++;
            }
        }
        
        const percentile = ((serverData.totalUsers - rank + 1) / serverData.totalUsers) * 100;
        return `#${rank} (Top ${percentile.toFixed(1)}%)`;
    },

    /**
     * CALCULATE PERFORMANCE GRADE
     */
    calculatePerformanceGrade(performanceMetrics) {
        const score = (
            Math.max(0, Math.min(100, performanceMetrics.profitabilityScore + 50)) * 0.4 +
            performanceMetrics.consistencyScore * 0.3 +
            performanceMetrics.gamingEfficiency * 0.3
        );
        
        if (score >= 90) return 'A+ EXCEPTIONAL';
        if (score >= 80) return 'A EXCELLENT';
        if (score >= 70) return 'B+ GOOD';
        if (score >= 60) return 'B AVERAGE';
        if (score >= 50) return 'C+ BELOW AVERAGE';
        if (score >= 40) return 'C POOR';
        return 'F FAILING';
    },

    /**
     * GENERATE MEGA COMPREHENSIVE ECONOMY CHART
     */
    async generateMegaEconomyChart(serverData, personalData, taxationData, gamblingData, targetUser) {
        const canvas = createCanvas(1200, 800);
        const ctx = canvas.getContext('2d');

        // Background
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, 1200, 800);

        // Title
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('COMPLETE ECONOMY ANALYSIS', 600, 30);
        ctx.font = 'bold 14px Arial';
        // Truncate long display names to prevent overflow
        const truncatedDisplayName = targetUser.displayName.length > 20 ? targetUser.displayName.substring(0, 17) + '...' : targetUser.displayName;
        ctx.fillText(`Focus: ${truncatedDisplayName} | Server: ${serverData.totalUsers} users`, 600, 55);

        // SECTION 1: Wealth Distribution (Top Left)
        this.drawWealthDistributionChart(ctx, serverData, 50, 80, 280, 200);
        
        // SECTION 2: Personal Analytics (Top Right)  
        this.drawPersonalAnalyticsChart(ctx, personalData, 370, 80, 280, 200);
        
        // SECTION 3: Tax Analysis (Middle Left)
        this.drawTaxAnalysisChart(ctx, taxationData, 50, 320, 280, 180);
        
        // SECTION 4: Gambling Performance (Middle Right)
        this.drawGamblingPerformanceChart(ctx, gamblingData, personalData, 370, 320, 280, 180);
        
        // SECTION 5: Risk Assessment (Bottom Left)
        this.drawRiskAssessmentChart(ctx, personalData.riskAssessment, 50, 540, 280, 180);
        
        // SECTION 6: Server Statistics (Bottom Right)
        this.drawServerStatsChart(ctx, serverData, gamblingData, 370, 540, 280, 180);

        // SECTION 7: Unified Timeline/Trend (Bottom Full Width)
        this.drawEconomicTrendChart(ctx, serverData, personalData, 680, 80, 480, 640);

        return canvas.toBuffer('image/png');
    },

    /**
     * DRAW WEALTH DISTRIBUTION CHART
     */
    drawWealthDistributionChart(ctx, serverData, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('WEALTH DISTRIBUTION', x + width/2, y - 10);

        const centerX = x + width/2;
        const centerY = y + height/2;
        const radius = 60;

        // Draw wealth concentration pie chart
        const categories = [
            { name: 'Top 1%', value: serverData.wealthDistribution.top1Percent.percentage, color: '#FFD700' },
            { name: 'Top 5%', value: serverData.wealthDistribution.top5Percent.percentage - serverData.wealthDistribution.top1Percent.percentage, color: '#FFA500' },
            { name: 'Top 10%', value: serverData.wealthDistribution.top10Percent.percentage - serverData.wealthDistribution.top5Percent.percentage, color: '#FF6347' },
            { name: 'Rest', value: 100 - serverData.wealthDistribution.top10Percent.percentage, color: '#4CAF50' }
        ];

        let startAngle = 0;
        categories.forEach(category => {
            const sliceAngle = (category.value / 100) * 2 * Math.PI;
            
            ctx.fillStyle = category.color;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
            ctx.lineTo(centerX, centerY);
            ctx.fill();
            
            startAngle += sliceAngle;
        });

        // Legend - moved inside chart area to prevent overflow
        ctx.font = '9px Arial';
        ctx.textAlign = 'left';
        categories.forEach((category, i) => {
            const legendY = y + height - 60 + (i * 12);
            ctx.fillStyle = category.color;
            ctx.fillRect(x + 5, legendY, 6, 6);
            ctx.fillStyle = '#FFFFFF';
            // Truncate long text to prevent overflow
            const shortName = category.name.length > 8 ? category.name.substring(0, 6) + '..' : category.name;
            ctx.fillText(`${shortName}: ${category.value.toFixed(1)}%`, x + 14, legendY + 5);
        });
    },

    /**
     * DRAW PERSONAL ANALYTICS CHART
     */
    drawPersonalAnalyticsChart(ctx, personalData, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        // Truncate long usernames to prevent overflow
        const truncatedName = personalData.username.length > 15 ? personalData.username.substring(0, 12) + '...' : personalData.username;
        ctx.fillText(`${truncatedName.toUpperCase()} ANALYTICS`, x + width/2, y - 10);

        // Wallet vs Bank pie chart
        const centerX = x + width/2;
        const centerY = y + height/3;
        const radius = 40;

        const walletPercent = personalData.wealthMetrics.walletPercent;
        const bankPercent = personalData.wealthMetrics.bankPercent;

        if (personalData.wealthMetrics.totalWealth > 0) {
            // Wallet slice
            const walletAngle = (walletPercent / 100) * 2 * Math.PI;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, walletAngle);
            ctx.lineTo(centerX, centerY);
            ctx.fill();

            // Bank slice
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, walletAngle, 2 * Math.PI);
            ctx.lineTo(centerX, centerY);
            ctx.fill();
        }

        // Performance bars
        ctx.font = '10px Arial';
        ctx.fillStyle = '#FFFFFF';
        
        const metrics = [
            { label: 'Win Rate', value: personalData.gamblingAnalysis.winRate, max: 100, color: '#4CAF50' },
            { label: 'ROI', value: Math.max(-100, Math.min(100, personalData.gamblingAnalysis.roi + 50)), max: 100, color: '#FF9800' },
            { label: 'Risk Score', value: personalData.riskAssessment.riskScore, max: 100, color: '#F44336' }
        ];

        metrics.forEach((metric, i) => {
            const barY = y + height/2 + 10 + (i * 20);
            const barWidth = (metric.value / metric.max) * (width - 40);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(x + 10, barY, width - 20, 12);
            
            ctx.fillStyle = metric.color;
            ctx.fillRect(x + 10, barY, barWidth, 12);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.fillText(metric.label, x + 10, barY - 2);
            ctx.textAlign = 'right';
            ctx.fillText(`${metric.value.toFixed(1)}`, x + width - 10, barY + 10);
        });
    },

    /**
     * DRAW TAX ANALYSIS CHART
     */
    drawTaxAnalysisChart(ctx, taxationData, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('WEALTH TAX ANALYSIS', x + width/2, y - 10);

        const centerX = x + width/2;
        const centerY = y + height/2;
        const radius = 50;

        const categories = [
            { name: 'Taxable', value: taxationData.summary.taxableUsers, color: '#FF6B35' },
            { name: 'High Stakes Exempt', value: taxationData.summary.highStakesGamblers, color: '#4CAF50' },
            { name: 'Other Exempt', value: taxationData.summary.exemptUsers - taxationData.summary.highStakesGamblers, color: '#2196F3' }
        ];

        const total = categories.reduce((sum, cat) => sum + cat.value, 0);
        
        if (total > 0) {
            let startAngle = 0;
            categories.forEach(category => {
                const sliceAngle = (category.value / total) * 2 * Math.PI;
                
                ctx.fillStyle = category.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fill();
                
                startAngle += sliceAngle;
            });
        }

        // Tax efficiency bar
        ctx.font = '12px Arial';
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.fillText(`Revenue: ${fmt(taxationData.summary.potentialTaxRevenue)}`, centerX, y + height - 20);
        ctx.fillText(`Efficiency: ${taxationData.taxEfficiency.collectionRate.toFixed(1)}%`, centerX, y + height - 5);
    },

    /**
     * DRAW GAMBLING PERFORMANCE CHART
     */
    drawGamblingPerformanceChart(ctx, gamblingData, personalData, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAMBLING PERFORMANCE', x + width/2, y - 10);

        // Top games bar chart
        const topGames = personalData.gamblingAnalysis.favoriteGames.slice(0, 5);
        const maxGames = Math.max(...topGames.map(g => g.gamesPlayed), 1);

        topGames.forEach((game, i) => {
            const barHeight = 15;
            const barY = y + 20 + (i * 25);
            const barWidth = (game.gamesPlayed / maxGames) * (width - 100);

            // Background
            ctx.fillStyle = '#333';
            ctx.fillRect(x + 80, barY, width - 100, barHeight);

            // Bar
            const winRate = parseFloat(game.winRate);
            ctx.fillStyle = winRate > 50 ? '#4CAF50' : '#F44336';
            ctx.fillRect(x + 80, barY, barWidth, barHeight);

            // Label
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(game.name.substring(0, 8), x + 5, barY + 12);
            ctx.textAlign = 'right';
            ctx.fillText(`${game.gamesPlayed}`, x + width - 5, barY + 12);
        });

        // Server comparison
        ctx.font = '10px Arial';
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.fillText(`Server Avg: ${gamblingData.overview.houseEdge.toFixed(1)}% House Edge`, x + width/2, y + height - 10);
    },

    /**
     * DRAW RISK ASSESSMENT CHART
     */
    drawRiskAssessmentChart(ctx, riskAssessment, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('RISK ASSESSMENT', x + width/2, y - 10);

        // Risk gauge
        const centerX = x + width/2;
        const centerY = y + height/2;
        const radius = 50;

        // Background gauge
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 15;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI);
        ctx.stroke();

        // Risk level gauge
        const riskAngle = (riskAssessment.riskScore / 100) * Math.PI;
        const riskColor = riskAssessment.riskScore >= 70 ? '#FF0000' : 
                         riskAssessment.riskScore >= 40 ? '#FFA500' : '#4CAF50';
        
        ctx.strokeStyle = riskColor;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, riskAngle);
        ctx.stroke();

        // Risk score text
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${riskAssessment.riskScore}`, centerX, centerY + 20);
        
        ctx.font = '10px Arial';
        ctx.fillText(riskAssessment.overallRiskLevel, centerX, centerY + 35);
    },

    /**
     * DRAW SERVER STATS CHART
     */
    drawServerStatsChart(ctx, serverData, gamblingData, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SERVER STATISTICS', x + width/2, y - 10);

        const stats = [
            { label: 'Users', value: serverData.totalUsers.toLocaleString(), color: '#4CAF50' },
            { label: 'Total Wealth', value: fmt(serverData.totalWealth), color: '#FFD700' },
            { label: 'Active Rate', value: `${((serverData.activityAnalysis.activeGamblers / serverData.totalUsers) * 100).toFixed(1)}%`, color: '#2196F3' },
            { label: 'Games Played', value: gamblingData.overview.totalGames.toLocaleString(), color: '#FF9800' },
            { label: 'House Edge', value: `${gamblingData.overview.houseEdge.toFixed(2)}%`, color: '#9C27B0' }
        ];

        stats.forEach((stat, i) => {
            const statY = y + 25 + (i * 30);
            
            ctx.fillStyle = stat.color;
            ctx.fillRect(x + 10, statY, 8, 8);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(stat.label, x + 25, statY + 7);
            ctx.textAlign = 'right';
            ctx.fillText(stat.value, x + width - 10, statY + 7);
        });
    },

    /**
     * DRAW ECONOMIC TREND CHART
     */
    drawEconomicTrendChart(ctx, serverData, personalData, x, y, width, height) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ECONOMIC HEALTH & TRENDS', x + width/2, y - 10);

        // Economic health indicators
        const indicators = [
            { name: 'Wealth Inequality', value: serverData.economicMetrics.giniCoefficient * 100, max: 100, color: '#FF6B35' },
            { name: 'Activity Rate', value: (serverData.activityAnalysis.activeGamblers / serverData.totalUsers) * 100, max: 100, color: '#4CAF50' },
            { name: 'Participation', value: (serverData.activityAnalysis.totalGamers / serverData.totalUsers) * 100, max: 100, color: '#2196F3' },
            { name: 'Personal ROI+50', value: Math.max(0, Math.min(100, personalData.gamblingAnalysis.roi + 50)), max: 100, color: '#FFD700' }
        ];

        const chartHeight = height - 100;
        const barWidth = (width - 80) / indicators.length;

        indicators.forEach((indicator, i) => {
            const barX = x + 40 + (i * barWidth);
            const barHeight = (indicator.value / indicator.max) * chartHeight;
            const barY = y + 40 + (chartHeight - barHeight);

            // Background bar
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, y + 40, barWidth - 10, chartHeight);

            // Value bar
            ctx.fillStyle = indicator.color;
            ctx.fillRect(barX, barY, barWidth - 10, barHeight);

            // Label
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            // Rotate text for labels
            ctx.save();
            ctx.translate(barX + (barWidth - 10)/2, y + height - 20);
            ctx.rotate(-Math.PI / 4);
            // Truncate long indicator names to prevent overflow
            const shortIndicatorName = indicator.name.length > 10 ? indicator.name.substring(0, 8) + '..' : indicator.name;
            ctx.fillText(shortIndicatorName, 0, 0);
            ctx.restore();

            // Value
            ctx.fillText(`${indicator.value.toFixed(1)}`, barX + (barWidth - 10)/2, barY - 5);
        });

        // Summary text
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFFFFF';
        const economicHealth = this.calculateEconomicHealth(serverData);
        ctx.fillText(`Overall Economic Health: ${economicHealth}`, x + width/2, y + height - 5);
    },

    /**
     * FILTER ECONOMY USERS - Exclude special categories
     * Excludes: Developer, OFF ECO users, Admins with permissions
     */
    async filterEconomyUsers(users, interaction = null) {
        const DEVELOPER_ID = '466050111680544798';
        const filteredUsers = [];
        
        for (const user of users) {
            // Skip developer
            if (user.user_id === DEVELOPER_ID) {
                continue;
            }
            
            // Skip OFF ECO users
            try {
                const isOffEco = await dbManager.databaseAdapter.isOffEconomy(user.user_id);
                if (isOffEco) {
                    continue;
                }
            } catch (error) {
                // If we can't check, assume regular user
            }
            
            // Skip admin users (if we have Discord interaction to check permissions)
            if (interaction && interaction.guild) {
                try {
                    const member = await interaction.guild.members.fetch(user.user_id).catch(() => null);
                    if (member && member.permissions.has('Administrator')) {
                        continue;
                    }
                } catch (error) {
                    // If we can't check, assume regular user
                }
            }
            
            filteredUsers.push(user);
        }
        
        return filteredUsers;
    },

    /**
     * GENERATE COMPREHENSIVE ECONOMY MANAGEMENT TIPS
     */
    generateEconomyTips(economicSystemData) {
        const tips = [];
        const healthScore = economicSystemData.healthScore;
        const emergencyMode = economicSystemData.emergencyMode;

        // Emergency mode tips
        if (emergencyMode) {
            tips.push("üö® **EMERGENCY MODE ACTIVE** - All games have increased restrictions");
            tips.push("‚ö†Ô∏è **Bet limits reduced** - Maximum bets are temporarily lowered");
            tips.push("üîí **Enhanced monitoring** - All large wins are being reviewed");
            tips.push("‚è∞ **Temporary measures** - Emergency mode auto-expires in 1 hour");
        }

        // Health score based recommendations
        if (healthScore >= 90) {
            tips.push("‚úÖ **Economy Excellent** - All systems operating optimally");
            tips.push("üí∞ **Stable conditions** - Normal betting limits and payouts");
            tips.push("üìà **Growth opportunity** - Consider promotional events");
        } else if (healthScore >= 70) {
            tips.push("üü° **Economy Good** - Minor adjustments in effect");
            tips.push("‚öñÔ∏è **Balanced state** - Moderate house edge adjustments");
            tips.push("üìä **Monitor trends** - Keep an eye on wealth distribution");
        } else if (healthScore >= 50) {
            tips.push("üü† **Economy Concerning** - Increased restrictions active");
            tips.push("‚ö†Ô∏è **Risk mitigation** - Multipliers reduced to protect stability");
            tips.push("üéØ **Focus on balance** - Avoid high-risk betting patterns");
        } else if (healthScore >= 30) {
            tips.push("üî¥ **Economy Poor** - Significant restrictions in place");
            tips.push("üö® **High alert** - Emergency measures may trigger soon");
            tips.push("üí° **Conservative play** - Lower bets recommended for all users");
        } else {
            tips.push("üíÄ **Economy Critical** - Severe restrictions active");
            tips.push("üÜò **Crisis mode** - Emergency intervention required");
            tips.push("üõë **Immediate action** - Consider pausing high-stakes games");
        }

        // User risk level tips
        const userRisk = economicSystemData.userRisk?.riskLevel || 'UNKNOWN';
        if (userRisk === 'HIGH' || userRisk === 'CRITICAL') {
            tips.push("üë§ **Your Risk: HIGH** - Your account has enhanced monitoring");
            tips.push("üìâ **Reduced multipliers** - Your payouts are automatically adjusted");
        } else if (userRisk === 'MEDIUM') {
            tips.push("üë§ **Your Risk: MEDIUM** - Some restrictions may apply");
        } else if (userRisk === 'LOW') {
            tips.push("üë§ **Your Risk: LOW** - Standard rates and limits apply");
        }

        // System-specific tips
        if (Object.keys(economicSystemData.multiplierReductions).length > 0) {
            tips.push("üéÆ **Dynamic adjustments** - Game payouts automatically optimized");
            tips.push("üè† **House edge active** - Ensures long-term stability");
        }

        // General economy tips
        tips.push("üí° **Pro tip:** Bank money to earn daily interest");
        tips.push("üìä **Monitor your ROI** - Track your gambling performance");
        tips.push("‚öñÔ∏è **Bet responsibly** - Never bet more than you can afford");
        tips.push("üéØ **Diversify games** - Don't focus on just one game type");

        return tips.slice(0, 8).join('\n'); // Limit to 8 tips to prevent overflow
    }
};